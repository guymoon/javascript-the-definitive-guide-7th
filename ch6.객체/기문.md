# 6장 객체

- JS 객체는 자신만의 프로퍼티를 가지는 것 외엥도
  → 프로토타입이라고 불리는 다른 객체에서 프로퍼티를 상속하기도 한다.
- JS에서 문자열, 숫자, 불리언, null, undefined, symbol 외 모두 객체
- 문자열, 숫자, 불은 객체가 아니지만 불변인 객체처럼 행동 할 수도 있음
- 객체는 가변이며 값이 아닌 참조로 조작
- 프로퍼티 이름에는 빈 문자열과 심벌을 포함해 어떤 문자든 쓸 수 있음
  → 그러나 같은 이름의 프로퍼티는 존재 할 수 없음

- 객체에서 정의한 프로퍼티와
  프로토타입 객체에서 상속한 프로퍼티를 구별하는 것이 중요 할 수 있음
- 상속되지 않은 프로퍼티를 자체 프로퍼티(own)

프로퍼티에는 이름과 값 외에도 다음과 같은 세가지 프로퍼티 속성이 있음

1. 쓰기 가능: 값을 설정할 수 있는지 없는지 
2. 열거 가능 : for/in 루프에 프로퍼티 이름을 반환할지 안 할지를 나타냄
3. 변경 가능: 삭제, 변경 할 수 있는지 없는지 

- JS내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나 열거 불가나 변경 불가
- 직접 만드는 객체의 프로퍼티는 기본적으로 쓰기 가능, 열거가능, 변경 가능

## 6.2 객체 생성

- 객체 리터럴
- new 키워드
- Object.create

를 사용해서 객체를 만들 수 있따.  

### 6.2.1. 객체 리터럴

- 프로퍼티 값은 JS 표현식이면 무엇이든 가능
- 기본 값이든 객체 값이든 프로퍼티 값이 된다.

- 객체 리터럴을 평가 할 때 마다 새 객체가 만들어진다.
- 각 프로퍼티의 값 역시 리터럴을 평가 할 때 마다 평가

→ 따라서 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새로운 객체를 여러 개 만들 수 있고, 이 객체들의 프로퍼티 값 역시 매번 달라질 수 있다.

### 6.2.2 new

- new 연산자는 새 객체를 생성하고 초기화
- new 키워드 뒤에는 반드시 함수 호출이 있어야 한다.
- 이러한 형태로 사용하는 함수를 생성자라고 부르고, 새로 생긴 객체를 초기화하는 목적으로 사용

### 6.2.3 프로토타입

![Screen Shot 2022-05-07 at 1.01.21 PM.jpg](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%201d157e8347ab469196554f905700ac41/Screen_Shot_2022-05-07_at_1.01.21_PM.jpg)

- 자신과 연결된 두 번째 객체
- 첫 번째 객체는 프로토타입에서 프로퍼티를 상속

- new 키워드와 생성자를 사용해 만든 객체는
  생성자 함수의 prototype 프로퍼티 값(constructor.prototype)을 자신의 프로토타입으로 사용
- 따라서 new Object() 로 생성한 객체는 {}로 생성한 객체와 마찬가지로 Object.prototype에서 상속
- 마찬가지로 new Array() 를 사용해 생성된 객체의 프로토타입은 Array.prototype
- new Date()를 사용해 생성한 객체의 프로토타입은 Date.prototype

- 거의 모든 객체에 프로토타입이 있지만 prototype 프로퍼티가 있는 객체는 비교적 적다
- prototype 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의
- Object.prototype은 프로토타입이 없는 드문 객체 중 하나
  - 어떤 프로퍼티도 상속하지 않음
  - 내장 생성자 대부분(사용자 정의 생성자 역시) Object.prototype에서 프로퍼티를 상속
  - 그래서 new Date() 로 생성한 Date 객체는 Date.prototype, Object.prototype 양쪽에서 프로퍼티 상속

### 6.x.x`[[Prototype]]` vs `prototype 프로퍼티`

[[Prototype]]

- 함수를 포함한 모든 객체가 가지고 있는 인터널 슬롯
- 객체의 입장에서는 자신의 부모 역할을 하는 프로토타입 객체를 가리키며
  → 함수의 경우네는 Function.prototype 을 가리킵니다.

prototype 프로퍼티

- 함수 객체만 가지고 있는 프로퍼티
- 함수 객체가 생성자로 사용될 때 
  → 생성될 객체의 프로토타입을 가리킨다.

### 6.x.x. constructor 프로퍼티

- 프로토타입 객체는 constructor 프로퍼티를 갖는다.
- constructor는 → 객체의 입장에서 자신을 생성한 객체를 가리킨다.
- `Person() 생성자 함수`로 생성된 객체가 `foo`라면 
  → foo 객체를 생성한 객체는 `Person() 생성자 함수`
  -> foo 객체의 프로토타입은 `Person.prototype`

→ `Person.prototype.constructor`는 `Person 생성자 함수`

### 6.x.x. Prototype chain

- 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 없으면
  → [[Prototype]]이 가리키는 링크를 따라 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색 
  → 프로토타입 체인

![Screen Shot 2022-05-07 at 1.17.02 PM.jpg](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%201d157e8347ab469196554f905700ac41/Screen_Shot_2022-05-07_at_1.17.02_PM.jpg)

- new 키워드와 생성자를 사용해 만든 객체는
  생성자 함수의 prototype 프로퍼티 값(constructor.prototype)을 자신의 프로토타입으로 사용
- 화살표 함수는 prototype이 없고 그래서 생성자 또한 없음 → 생성자 함수로 사용 할 수 없음

### 6.2.4. Object.create()

- 첫 번째 인자를 프로토타입 삼아 객체를 생성
- 임의의 프로토타입을 사용해 새 객체를 만들 수 있는 것은 강력한 기능을 사용 할 수 있음
- 인자로 null을 전달해 프로토타입이 없는 객체를 생성 할 수 있지만 이렇게 생성된 객체는 아무 것도 상속하지 않고, toString 같은 기본 메서드 조차 없음, + 연산자와 함께 쓸 수도 없음

- Object.create(Object.prototype)
- {}
- new Object()

결과는 모두 같다.

- 써드 파티 라이브러리에서 객체를 변경하는 사고를 막을 수도 있음
- 객체를 라이브러리 함수에 전달하지 않고, 원래 객체를 상속하는 객체를 전달하면, 그 함수는 아무 문제 없이 상속된 값을 읽을 수 있음.
- 라이브러리에서 부주의하게 프로퍼티 값을 바꾸더라도 원래 객체에는 영향이 없음

→ 프로퍼티를 검색하고 설정하는 방식에 대한 이해가 있어야 한다. 

### 6.3.1 연관 배열인 객체

- 문자열을 인덱스로 사용하는 것을 associative array(연관 배열)

- JS는 타입을 업격하게 고정하지 않아
  → 객체의 프로퍼티 개수가 고정되어 있고, 프로퍼티 이름 역시 미리 정의되어 있지 않아도 됨

- 식별자는 반드시 문자 그대로 프로그램에 입력해야 하고,
  식별자는 데이터 타입이 아니므로 프로그램에서 조작 할 수 없음

    → 대괄호 표기법 사용가능

- 프로퍼티 이름을 미리 알수 없고, 이럴 때 점 연산자를 쓰면 문제가 생길 수 있으니 대괄호 표기법

### 6.3.2. 상속

- 객체의 prototype 속성은 자신이 어디에서 프로퍼티를 상속했는지 나타내는 체인을 형성

- 체인을 따라 검색해가는데 상속된 프로퍼티 x가 있는 상태에서 자체 프로퍼티 x로 값을 넣어주면
  → 이후에 찾아과는 과정이 멈추기 때문에 상속된 x가 가려짐

    → 쉐도잉

- 할당하는 것이 프로토타입 체인에 존재하는 객체를 수정하지는 않음

- o가 x를 상속하고,
  그 프로퍼티가 세터 메서드가 있는 접근자라면,
  o에 x 프로퍼티를 새롭게 만드는 대신 → 세터 메서드 호출

- 세터 메서드는 객체 o에 호출되는 것이지, 해당 프로퍼티를 정의한 프로토타입 객체에 호출되는 것은 아니므로 → o에 변화만 있을 뿐 프로토타입 체인은 변하지 않음

### 6.4 프로퍼티 삭제

- delete는 삭제에 성공했을 때, 존재하지 않는 프로퍼티를 삭제를 시도하는 등의 효과가 없을 때 
  → 모두 true
- delete는 변경 가능 속성이 false인 경우 제거하지 않음
- 내장 객체의 일부 프로퍼티, 전역 객체의 프로퍼티는 변경 불가(변수 선언, 함수 선언으로 생성된)

## 6.5 프로퍼티 테스트

- in - 자체 혹은 상속된 프로퍼티가 있다면 true
- hasOwnProperty - 자체 프로퍼티만 테스트. 상속된 프로퍼티가 있더라도 false
- propertyIsEnumerable - 자체 프로퍼티 && 열거 가능 속성이 true일 경우만

## 6.6 프로퍼티 열거

- keys(): 열거 불가, 상속된, 이름이 심벌인 프로퍼티는 내보내지 않음
- getOwnPropertyNames - 문자열이기만 하면 열거 불가인 자체 프로퍼티 이름도 배열로 반환
- getOwnPropertySymbols - 열거 가능 여부를 따지지 ㅇ낳고, 이름이 심벌인 자체 프로퍼티를 배열로 반환
- Reflect.onwKeys() - 열거 가능 여부를 따지지 않고 문자열인지 심벌인지도 구분하지 않고, 자체 프로퍼티 이름은 전부 배열로 반환

열거 순서

![Screen Shot 2022-05-07 at 1.27.09 PM.jpg](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%201d157e8347ab469196554f905700ac41/Screen_Shot_2022-05-07_at_1.27.09_PM.jpg)

166p

## 6.7  - Object.assign(타겟, 소스)

- 소스 객체에 기본 값을 정의해 두고, 대상 객체에 그런 이름이 존재하지 않는다면 복사해 쓸 수 있음
- 소스 객체에 게터 메서드가 있거나 대상 객체에 세터 메서드가 있으면 → 복사 도중 이들이 호출되긴 하지만 메서드 자체를 복사하지는 않음

## 6.8 객체 직렬화

- 객체를 문자열로 반환하는 작업
- JSON.stringfy, JSON.parse
- JSON은 JS 객체 표기법(js object notation) 객체와 배열 리터럴과 유사
- Date 객체와 같은 것은 복원하지 않음
- 열거 가능한 자체 프로퍼티만 직렬화. 프로퍼티 값을 직렬화 할 수 없으면 문자열에서 생략

## 6.9 객체 메서드

- toString : 호출한 객체의 값을 나타내는 문자열을 반환
- 객체를 문자열로 변환 할 때 마다 이 메서드 호출

### 6.9.2 toLocaleString

- 지역에 맞는 문자열 표현 반환
- 다른 것은 해당 사항 없고 Date와 숫자 클래스에는 숫자 날짜 시간을 지역의 관습에 맞게 표현 할 수 있음
- toString과 거의 비슷하지만 배열 요소를 변환 할 때 toString대신 toLocaleString() 메서드 호출한다는 점이 다름

### 6.9.3. valueOF

- toString과 비슷하지만 객체를 문자열이 아닌 다른 기본 타입,
  → 보통 숫자로 변환하려할떄 호출
- js는 기본 값을 예쌍하는 곳에 객체를 사용하면 자동으로 이 메서드 호출
- Date 클래스의 valueOF는 날짜를 숫자로 변환하므로 시간 순서를 비교 할 수 있음

### 6.9.4 toJSON

- JSON 직렬화 과정에서 직렬화 할 객체에서 toJSON 메서드를 검색
- 직렬화할 객체에 이런 메서드가 존재하면 해당 메서드를 호출해 반환 값을 직렬화 한다.

### 6.10.4 분해 연산자

- 분해되는 객체와 프로퍼티를 받는 객체 둘 다 같은 이름의 프로퍼티를 갖는다면 해당 프로퍼티의 값은 마지막에 오는 값
- 분해 연산자는 자체 프로퍼티만 분해할 뿐 상속된 프로퍼티에는 적용되지 않음

### 6.10.6 게터세터

- 접근자 메서드 게터와 세터를 갖는 접근자 프로퍼티 지원
- 검색하면 →인자 없이 게터 메서드를 호출
- 게터 세터 모두 있으면 읽기 쓰기 가능한 프로퍼티
- 접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속

리터럴로하면 모두 true, Object.create로 만들면 모두 false

![Screen Shot 2022-05-07 at 1.43.52 PM.jpg](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%201d157e8347ab469196554f905700ac41/Screen_Shot_2022-05-07_at_1.43.52_PM.jpg)
